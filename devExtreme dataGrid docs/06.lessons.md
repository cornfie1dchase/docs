## 使用经验与优化

> ​	本章节讲述一些使用过程中的经验或当前实现方案，希望能够为大家提供一些解决问题的思路。但这只是前期解决问题时形成的一种方法，有其局限性。希望大家能够集思广益，结合业务需求和组件基础，多思考探索，在业务开发时使用更合适的解决方案。

### 将loadOptions处理成数据请求

​	前面介绍了CustomStore中的load函数，入参loadOptions的具体属性依赖表格设置。以`remoteOperations: { groupPaging: true }`为例，通过上一章节的介绍，我们知道这样设置时，所有操作都由服务端进行数据处理。

```javascript
//...远程操作设置如下，且表格对应操作功能都开启时，
DxDataGrid.configs.remoteOperations={ groupPaging: true }
//... loadOptions如下所示，会包含以下属性，在不同操作时有差异
//		我们在load函数中要做的，就是根据这些属性，处理好数据，响应表格当前触发的操作
new DataSource({
  store: new CustomStore({
    loadMode: 'processed',
    load:(loadOptions)=>{
      // loadOptions 
      const {
        filter,
        group,
        requireTotalCount,
     		//...
        skip,
        sort,
        take,
        totalSummary,
      } = loadOptions
      //... data process
      return {
        data:[],
        //...
      }
    }
  })
})
```

​	前面我们了解过，需要根据loadOptions中的属性返回表格所需的数据对象。返回的数据对象中必须包含data<Array>属性，其他属性则根据入参loadOptions的属性值来决定。

```js
// ... 
load:(loadOptions)=>{
      const {
        requireTotalCount,
     		//...
        totalSummary,
      } = loadOptions
      const result ={
        data: [] //必须
      }
       if (totalSummary && totalSummary.length){
        // 存在totalSummary<Array>时，返回值中需要包含summary属性
        // 根据totalSummary中的对象{selector: '${dataField}', summaryType: 'sum'}selector字段有序返回对应值
        // totalSummary = [{selector: 'count', summaryType:'count' },{selector: 'sum', summaryType:'sum' }]
        // {count:2, sum: 3}
        result.summary=[2, 3]
      }
  		if (requireTotalCount){
        // requireTotalCount是一个Boolean值,为true时，返回值需要包含totalCount属性
        result.totalCount=10
      }
      return result
    }
```

```js
//...
const {group,groupSummary,requireGroupCount, sort, /**...*/ } = loadOptions
//... group<Array>... 当存在group数组时，返回的数据为分组数据，并且需要返回groupCount字段
// group是分组对象组成的有序数组，顺序与界面分组数据加载顺序一致
// 每一层级的分组展开操作单独获取该层级数据
const groupData = {
  data: []
}
{
  data: [],//groupList
  groupCount: 10
}
return groupData

//... sort<Array> ... sort: [{selector: 'count',desc: true},{...}]
// sort参数不改变返回值属性，仅改变data数组中的顺序
// sort也是有序数组，根据每个对象中的selector值和desc状态进行多维度排序；大部分业务场景中为单维度排序，取第一个对象，处理成排序参数即可。
// eg: 
let sortParams = {
  sortAscFlag: Number(!sort[0].desc),
  factorOrder:{
    panzFactorEname: s.selector
  }
}
```

```js
// skip & take
// 表格设置滚动模式为virtual或infinite时，loadOptions中的skip和take表示本次需加载的数据；
// 按当前排序，skip为起始位置，take为数据量
// skip=40 take=20 表示跳过前40个，从41开始取20条数据，[41-60]

// 处于数据边界或分组边界时，skip和take会出现undefined的情况。这时我们需要根据使用场景进行特殊处理。
// 例如当前项目中遇到这种情况会情况后续4页*20、总共80条数据，该处理能改保证请求到全部数据，但会产生额外请求。
// 表格会根据DataSource中配置的pageSize（默认值20）生成skip和take，将skip与take处理成数据请求时，尽可能选用合适的pageSize作为基准。

```

```js
// filter<Array>
// filter的值依据表格展开状态，每一个 最下层展开的分组 连同父系展开分组构成一个Array；多个Array用'or'连接
// filter有着较为复杂的规则和结构，在当前业务应用中，基本只用于分组展开时筛选多级分组下、某一分组的数据；对应filter中不包含'or'的一个Array，若filter中有'or'字符拼接多个Array，则需要分割成多个请求条件。
// 
```

### 分组汇总行与汇总行配置

​	业务开发过程中，除了正确使用组件，充分利用组件能力，有时还需要处理一些不符合组件设计的功能需求。

​	例如，groupSummary通常需要配置`alignByColumn： true`，使数据在对应列位置渲染。当表格有横向滚动条时，分组数据会跟随列位置移动。部分情况下会使表格分组条件不可见。

​	处理该问题时，我们在分组和取消分组时进行配置，将当前分组的列固定到左侧；但这并没有解决问题，一个分组列固定，数据依然遵循`alignByColumn： true`



### 渲染优化

[渲染优化]: https://js.devexpress.com/DevExtreme/Guide/UI_Components/DataGrid/Enhance_Performance_on_Large_Datasets/#Rendering_Optimization

### 样式修改